{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"Async fork of FastAPI JWT Auth  <p>Original lib:</p> <p>Documentation: https://indominusbyte.github.io/fastapi-jwt-auth</p> <p>Source Code: https://github.com/IndominusByte/fastapi-jwt-auth</p> <p>Async fork:</p> <p>Documentation: https://sijokun.github.io/async-fastapi-jwt-auth</p> <p>Source Code: https://github.com/sijokun/async-fastapi-jwt-auth/</p>"},{"location":"#features","title":"Features","text":"<p>FastAPI extension that provides JWT Auth support (secure, easy to use and lightweight), if you were familiar with flask-jwt-extended this extension suitable for you, cause this extension inspired by flask-jwt-extended \ud83d\ude00</p> <ul> <li>Access tokens and refresh tokens</li> <li>Freshness Tokens</li> <li>Revoking Tokens</li> <li>Support for WebSocket authorization</li> <li>Support for adding custom claims to JSON Web Tokens</li> <li>Storing tokens in cookies and CSRF protection</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to start working with this extension with pip</p> <pre><code>pip install async-fastapi-jwt-auth\n</code></pre> <p>If you want to use asymmetric (public/private) key signing algorithms, include the asymmetric extra requirements. <pre><code>pip install 'async-fastapi-jwt-auth[asymmetric]'\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"api-doc/","title":"API Documentation","text":"<p>In here you will find the API for everything exposed in this extension.</p>"},{"location":"api-doc/#configuring-fastapi-jwt-auth","title":"Configuring FastAPI JWT Auth","text":"load_config(callback) <p>This decorator sets the callback function to overwrite state on AuthJWT class so when you initialize an instance in dependency injection default value will be overwritten.</p> <p>Hint: The callback must be a function that returns a list of tuple or pydantic object.</p> token_in_denylist_loader(callback) <p>This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the JWT has been revoked. By default, this callback is not used.</p> <p>Hint: The callback must be a function that takes <code>one</code> argument, which is the decoded JWT (python dictionary), and returns <code>True</code> if the token has been revoked, or <code>False</code> otherwise.</p>"},{"location":"api-doc/#protected-endpoint","title":"Protected Endpoint","text":"jwt_required(auth_from=\"request\", token=None, websocket=None, csrf_token=None) <p>If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. This does not check the freshness of the access token.</p> <ul> <li>Parameters:<ul> <li>auth_from: For identity get token from HTTP or WebSocket</li> <li>token: The encoded JWT, it's required if the protected endpoint use WebSocket to              authorization and get token from Query Url or Path</li> <li>websocket: An instance of WebSocket, it's required if protected endpoint use a cookie to authorization</li> <li>csrf_token: The CSRF double submit token. Since WebSocket cannot add specifying additional headers                   its must be passing csrf_token manually and can achieve by Query Url or Path</li> </ul> </li> <li>Returns: None</li> </ul> jwt_optional(auth_from=\"request\", token=None, websocket=None, csrf_token=None) <p>If an access token present in the request, this will call the endpoint with <code>get_jwt_identity()</code> having the identity of the access token. If no access token is present in the request, this endpoint will still be called, but <code>get_jwt_identity()</code> will return None instead.</p> <p>If there is an invalid access token in the request (expired, tampered with, etc), this will still call the appropriate error handler.</p> <ul> <li>Parameters:<ul> <li>auth_from: For identity get token from HTTP or WebSocket</li> <li>token: The encoded JWT, it's required if the protected endpoint use WebSocket to              authorization and get token from Query Url or Path</li> <li>websocket: An instance of WebSocket, it's required if protected endpoint use a cookie to authorization</li> <li>csrf_token: The CSRF double submit token. Since WebSocket cannot add specifying additional headers                   its must be passing csrf_token manually and can achieve by Query Url or Path</li> </ul> </li> <li>Returns: None</li> </ul> jwt_refresh_token_required(auth_from=\"request\", token=None, websocket=None, csrf_token=None) <p>If you call this function, it will ensure that the requester has a valid refresh token before executing the code below your router.</p> <ul> <li>Parameters:<ul> <li>auth_from: For identity get token from HTTP or WebSocket</li> <li>token: The encoded JWT, it's required if the protected endpoint use WebSocket to              authorization and get token from Query Url or Path</li> <li>websocket: An instance of WebSocket, it's required if protected endpoint use a cookie to authorization</li> <li>csrf_token: The CSRF double submit token. Since WebSocket cannot add specifying additional headers                   its must be passing csrf_token manually and can achieve by Query Url or Path</li> </ul> </li> <li>Returns: None</li> </ul> fresh_jwt_required(auth_from=\"request\", token=None, websocket=None, csrf_token=None) <p>If you call this function, it will ensure that the requester has a valid and fresh access token before executing the code below your router.</p> <ul> <li>Parameters:<ul> <li>auth_from: For identity get token from HTTP or WebSocket</li> <li>token: The encoded JWT, it's required if the protected endpoint use WebSocket to              authorization and get token from Query Url or Path</li> <li>websocket: An instance of WebSocket, it's required if protected endpoint use a cookie to authorization</li> <li>csrf_token: The CSRF double submit token. Since WebSocket cannot add specifying additional headers                   its must be passing csrf_token manually and can achieve by Query Url or Path</li> </ul> </li> <li>Returns: None</li> </ul>"},{"location":"api-doc/#utilities","title":"Utilities","text":"create_access_token(subject, fresh=False, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) <p>Create a new access token.</p> <ul> <li>Parameters:<ul> <li>subject: Identifier for who this token is for example id or username from database</li> <li>fresh: Identify token is fresh or non-fresh</li> <li>algorithm: Algorithm allowed to encode the token</li> <li>headers: Valid dict for specifying additional headers in JWT header section</li> <li>expires_time: Set the duration of the JWT</li> <li>audience: Expected audience in the JWT</li> <li>user_claims: Custom claims to include in this token. This data must be dictionary</li> </ul> </li> <li>Returns: An encoded access token</li> </ul> create_refresh_token(subject, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) <p>Creates a new refresh token.</p> <ul> <li>Parameters:<ul> <li>subject: Identifier for who this token is for example id or username from database</li> <li>algorithm: Algorithm allowed to encode the token</li> <li>headers: Valid dict for specifying additional headers in JWT header section</li> <li>expires_time: Set the duration of the JWT</li> <li>audience: Expected audience in the JWT</li> <li>user_claims: Custom claims to include in this token. This data must be dictionary</li> </ul> </li> <li>Returns: An encoded refresh token</li> </ul> set_access_cookies(encoded_access_token, response=None, max_age=None) <p>Configures the response to set access token in a cookie. This will also set the CSRF double submit values in a separate cookie.</p> <ul> <li>Parameters:<ul> <li>encoded_access_token: The encoded access token to set in the cookies</li> <li>response: The FastAPI response object to set the access cookies in</li> <li>max_age: The max age of the cookie value should be <code>integer</code> the number of seconds</li> </ul> </li> <li>Returns: None</li> </ul> set_refresh_cookies(encoded_refresh_token, response=None, max_age=None) <p>Configures the response to set refresh token in a cookie. This will also set the CSRF double submit values in a separate cookie.</p> <ul> <li>Parameters:<ul> <li>encoded_refresh_token: The encoded refresh token to set in the cookies</li> <li>response: The FastAPI response object to set the refresh cookies in</li> <li>max_age: The max age of the cookie value should be <code>integer</code> the number of seconds</li> </ul> </li> <li>Returns: None</li> </ul> unset_jwt_cookies(response=None) <p>Unset (delete) all jwt stored in a cookies.</p> <ul> <li>Parameters:<ul> <li>response: The FastAPI response object to delete the JWT cookies in</li> </ul> </li> <li>Returns: None</li> </ul> unset_access_cookies(response=None) <p>Remove access token and access CSRF double submit from the response cookies.</p> <ul> <li>Parameters:<ul> <li>response: The FastAPI response object to delete the access cookies in</li> </ul> </li> <li>Returns: None</li> </ul> unset_refresh_cookies(response=None) <p>Remove refresh token and refresh CSRF double submit from the response cookies.</p> <ul> <li>Parameters:<ul> <li>response: The FastAPI response object to delete the refresh cookies in</li> </ul> </li> <li>Returns: None</li> </ul> get_raw_jwt(encoded_token=None) <p>This will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint. If no JWT is currently present, return <code>None</code> instead.</p> <ul> <li>Parameters:<ul> <li>encoded_token: The encoded JWT from parameter</li> </ul> </li> <li>Returns: Claims of JWT</li> </ul> get_jti(encoded_token) <p>Returns the JTI (unique identifier) of an encoded JWT</p> <ul> <li>Parameters:<ul> <li>encoded_token: The encoded JWT from parameter</li> </ul> </li> <li>Returns: String of JTI</li> </ul> get_jwt_subject() This will return the subject of the JWT that is accessing the endpoint. If no JWT is present, <code>None</code> is returned instead. get_unverified_jwt_headers(encoded_token=None) <p>Returns the Headers of an encoded JWT without verifying the actual signature of JWT.</p> <ul> <li>Parameters:<ul> <li>encoded_token: The encoded JWT to get the Header from protected endpoint or from parameter</li> </ul> </li> <li>Returns: JWT header parameters as a dictionary</li> </ul>"},{"location":"contributing/","title":"Development - Contributing","text":""},{"location":"contributing/#sharing-feedback","title":"Sharing feedback","text":"<p>This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . If you want to contribute thankss a lot , you can open an issue on Github.</p>"},{"location":"contributing/#developing","title":"Developing","text":"<p>If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"contributing/#virtual-environment-with-venv","title":"Virtual environment with venv","text":"<p>You can create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>$ python3 -m venv env\n</code></pre> <p>That will create a directory <code>./env/</code> with the Python binaries and then you will be able to install packages for that isolated environment.</p>"},{"location":"contributing/#activate-the-environment","title":"Activate the environment","text":"<pre><code>$ source ./env/bin/activate\n</code></pre> <p>To check it worked, use:</p> <pre><code>$ which pip\n\nsome/directory/fastapi-jwt-auth/env/bin/pip\n</code></pre> <p>If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89</p> <p>Tip</p> <p>Every time you install a new package with <code>pip</code> under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like <code>flit</code>), you use the one from your local environment and not any other that could be installed globally.</p>"},{"location":"contributing/#flit","title":"Flit","text":"<p>FastAPI JWT Auth uses Flit to build, package and publish the project.</p> <p>After activating the environment as described above, install <code>flit</code>:</p> <pre><code>$ pip install flit\n</code></pre> <p>Now re-activate the environment to make sure you are using the <code>flit</code> you just installed (and not a global one).</p> <p>And now use <code>flit</code> to install the development dependencies:</p> <pre><code>$ flit install --deps develop --symlink\n</code></pre> <p>It will install all the dependencies and your local FastAPI JWT Auth in your local environment.</p> <p>Using your local FastAPI JWT Auth</p> <p>If you create a Python file that imports and use FastAPI JWT Auth, and run it with the Python from your local environment, it will use your localFastAPI JWT Auth source code.</p> <p>And if you update that local FastAPI JWT Auth source code, as it is installed with <code>--symlink</code>, when you run that Python file again, it will use the fresh version of FastAPI JWT Auth you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"contributing/#docs","title":"Docs","text":"<p>The documentation uses MkDocs.</p> <p>All the documentation is in Markdown format in the directory <code>./docs</code>.</p> <p>Many of the sections in  the User Guide have blocks of code.</p> <p>In fact, those blocks of code are not written inside the Markdown, they are Python files in the <code>./examples/</code> directory.</p> <p>And those Python files are included/injected in the documentation when generating the site.</p>"},{"location":"contributing/#docs-for-tests","title":"Docs for tests","text":"<p>Most of the tests actually run against the example source files in the documentation.</p> <p>This helps making sure that:</p> <ul> <li>The documentation is up to date.</li> <li>The documentation examples can be run as is.</li> <li>Most of the features are covered by the documentation, ensured by test coverage.</li> </ul> <p>During local development, there is a script that builds the site and checks for any changes, live-reloading:</p> <pre><code>$ bash scripts/docs-live.sh\n</code></pre> <p>It will serve the documentation on <code>http://0.0.0.0:5000</code>.</p> <p>That way, you can edit the documentation/source files and see the changes live.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>There is a script that you can run locally to test all the code and generate coverage reports in HTML:</p> <pre><code>$ bash scripts/tests.sh\n</code></pre> <p>This command generates a directory <code>./htmlcov/</code>, if you open the file <code>./htmlcov/index.html</code> in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#async-fork-064","title":"Async fork 0.6.4","text":"<ul> <li>Dependencies are now use &gt;=, so everything should be fine.</li> <li>Examples for Swagger (OpenAPI) authorization</li> </ul>"},{"location":"release-notes/#async-fork-063","title":"Async fork 0.6.3","text":"<ul> <li>Dependencies are updated to latest, but somebody (Me) done it wrong, would be fixed in 0.6.4</li> </ul>"},{"location":"release-notes/#async-fork-062","title":"Async fork 0.6.2","text":"<ul> <li>OpenAPI now shows field for auth token. Thx to @SunnyCapt <pre><code>from async_fastapi_jwt_auth.auth_jwt import AuthJWT, AuthJWTBearer\nfrom fastapi import Depends\n\nauth_dep = AuthJWTBearer()\n\n@app.get(\"/protected\")\nasync def protected(Authorize: AuthJWT = Depends(auth_dep)):\n    await Authorize.jwt_required()\n    return {\"success\": True}\n</code></pre></li> </ul>"},{"location":"release-notes/#async-fork-061","title":"Async fork 0.6.1","text":"<ul> <li>Fix CHANGELOG.md, test action</li> </ul>"},{"location":"release-notes/#async-fork-060","title":"Async fork 0.6.0","text":"<ul> <li>Poetry, Pydantic 2.0</li> </ul>"},{"location":"release-notes/#async-fork-050","title":"Async fork 0.5.0","text":"<ul> <li>Now you can use this lib with async!</li> </ul>"},{"location":"release-notes/#050","title":"0.5.0","text":"<ul> <li>Support for WebSocket authorization (Thanks to @SelfhostedPro for make issues)</li> <li>Function get_raw_jwt() can pass parameter encoded_token</li> </ul>"},{"location":"release-notes/#040","title":"0.4.0","text":"<ul> <li>Support set and unset cookies when returning a Response directly</li> </ul>"},{"location":"release-notes/#030","title":"0.3.0","text":"<ul> <li>(Deprecated) environment variable support</li> <li>Change name function load_end() -&gt; load_config()</li> <li>Change name function get_jwt_identity() -&gt; get_jwt_subject()</li> <li>Change name identity claims to standard claims sub (Thanks to @rassie for suggestion)</li> <li>Additional headers in claims</li> <li>Get additional headers claims from request or parsing token directly</li> <li>Leeway exp claim decode token</li> <li>Dynamic token expires time</li> <li>Change name blacklist -&gt; denylist</li> <li>Denylist custom check refresh and access tokens</li> <li>Issuer claim</li> <li>Audience claim</li> <li>Jwt decode algorithms</li> <li>Dynamic algorithm create token</li> <li>Token multiple location</li> <li>Support RSA encryption (Thanks to @jet10000 for make issues)</li> <li>Custom header name and type</li> <li>Custom error message key and status code</li> <li>JWT in cookies (Thanks to @m4nuC for make issues)</li> <li>Add Additional claims</li> <li>Add Documentation PR #9 by @paulussimanjuntak</li> </ul>"},{"location":"release-notes/#020","title":"0.2.0","text":"<ul> <li>Call create_token and get_jti function must be from dependency injection</li> <li>Improve blacklist loader</li> <li>Can load env from pydantic</li> <li>Add docs on readme how to use without dependency injection and example on multiple files</li> <li>Fix raise jwt exception PR #1 by @ironslob </li> </ul>"},{"location":"release-notes/#010","title":"0.1.0","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"advanced-usage/additional-claims/","title":"Additional claims","text":"<p>You may want to store additional information in the access token or refresh token and you could later access in the protected views. This can be done easily by parsing additional information (dictionary python) to parameter user_claims in function create_access_token() or create_refresh_token(), and the data can be accessed later in a protected endpoint with the get_raw_jwt() function.</p> <p>Storing data in the tokens can be good for performance. If you store data in the tokens, you won't need to look it up from disk next time you need it in a protected endpoint. However, you should take care of what data you put in the tokens. Any data in the tokens can be trivially viewed by anyone who can read the tokens.</p> <p>Note: Do not store sensitive information in the tokens!</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # You can be passing custom claim to argument user_claims\n    # in function create_access_token() or create refresh token()\n    another_claims = {\"foo\": [\"fiz\", \"baz\"]}\n    access_token = await authorize.create_access_token(\n        subject=user.username, user_claims=another_claims\n    )\n    return {\"access_token\": access_token}\n\n\n# In protected route, get the claims you added to the jwt with the\n# get_raw_jwt() method\n@app.get(\"/claims\")\nasync def user(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    foo_claims = (await authorize.get_raw_jwt())[\"foo\"]\n    return {\"foo\": foo_claims}\n</code></pre>"},{"location":"advanced-usage/asymmetric/","title":"Asymmetric Algorithm","text":"<p>Usage of RSA <code>RS*</code> and EC <code>EC*</code> algorithms require a basic understanding of how public-key cryptography is used with regards to digital signatures. If you are familiar with that, you may want to use this.</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\n# In the real case, you can put the\n# public key and private key in *.pem, *.key then you can read that file\nprivate_key = \"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMIICWwIBAAKBgGBoQhqHdMU65aSBQVC/u9a6HMfKA927aZOk7HA/kXuA5UU4Sl+U\nC9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJQ6QXLnUyMnfwPmwYQ2rkuy5w\nI2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwXCxZ/IoiqN4jVNjSrAgMBAAEC\ngYAnNqEUq146zx8TT6PilWpxB9inByuVaCKkdGPbsG+bfa1D/4Z44/4AUsdpx5Ra\ns/hBkMRcIOsSChMAUe8xcK0DqA9Y7BIVfpma2fH/gYq6dP3dOfCxftZBF00HwIu7\n5e7RWnBC8MkPnrkKdHq6ptAYlGgoSJTEQREqusDiuNG9yQJBAKQib2VhNAqgyvvi\nPdmFrCqq15z9MY16WCfttuqfAaSYKHnZe1WvBKbSNW9x4Cgjfhzl9mlozlW4rob/\nttPN6e0CQQCWXbVtqmVdB5Ol9wQN7DIRc8q5F8HKQqIJAMTmwaRwNDsGRxCWMwGO\n8WAlnejzYTXmrrytv6kXX8U40enJW2X3AkAI42h+5/WmgbCcVVMeHXQGV3wXn0p4\nq+BsQR4/tF6laCwA9TsNl827rvR/1X3bDpj8vaNLcAaEc9zXqK9g5uy9AkATeOkw\n3Xso8/075eRBhU/qkKs1Ew2GiuB+9/mHxJXt7eWi53sPaGWQRFPmKy/qrLEVQZWv\njn1wSHe65vw2lj57AkEAh04n1wrZnCha8s6crMhjggdTXI6G4FU3TGf8ssGboqs3\nj5lemvyKod+u2JVKwarcKmd/gFYBOjsRm18LlZH74A==\n-----END RSA PRIVATE KEY-----\n\"\"\"\npublic_key = \"\"\"\n-----BEGIN PUBLIC KEY-----\nMIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgGBoQhqHdMU65aSBQVC/u9a6HMfK\nA927aZOk7HA/kXuA5UU4Sl+UC9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJ\nQ6QXLnUyMnfwPmwYQ2rkuy5wI2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwX\nCxZ/IoiqN4jVNjSrAgMBAAE=\n-----END PUBLIC KEY-----\n\"\"\"\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_algorithm: str = \"RS512\"\n    authjwt_public_key: str = public_key\n    authjwt_private_key: str = private_key\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"},{"location":"advanced-usage/bigger-app/","title":"Bigger Applications","text":"<p>Because fastapi-jwt-auth configure your setting via class state that applies across all instances of the class. You need to make sure to call load_config(callback) above from your endpoint. Thanks to <code>FastAPI</code> when you make endpoint from <code>APIRouter</code> it will actually work as if everything was the same single app.</p> <p>So you only need to define load_config(callback) where <code>Fastapi</code> instance created or you can import it where you included all the router. </p>"},{"location":"advanced-usage/bigger-app/#an-example-file-structure","title":"An example file structure","text":"<p>Let's say you have a file structure like this:</p> <pre><code>.\n\u251c\u2500\u2500 multiple_files\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 app.py\n\u2502   \u2514\u2500\u2500 routers\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 items.py\n\u2502       \u2514\u2500\u2500 users.py\n</code></pre> <p>Here an example of <code>app.py</code></p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\nfrom routers import items, users\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\n\napp = FastAPI()\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\napp.include_router(users.router, tags=[\"users\"])\napp.include_router(items.router, tags=[\"items\"])\n</code></pre> <p>Here an example of <code>users.py</code></p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nrouter = APIRouter()\nauth_dep = AuthJWTBearer()\n\n\n@router.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    return {\"access_token\": access_token}\n</code></pre> <p>Here an example of <code>items.py</code></p> <pre><code>from fastapi import APIRouter, Depends\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\n\nrouter = APIRouter()\nauth_dep = AuthJWTBearer()\n\n\n@router.get(\"/items\")\nasync def items(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    items = [\"item1\", \"item2\", \"item3\"]\n\n    return {\"items\": items}\n</code></pre>"},{"location":"advanced-usage/dynamic-algorithm/","title":"Dynamic Token Algorithm","text":"<p>You can specify which algorithm you would like to use to sign the JWT by using the algorithm parameter in create_access_token() or create_refresh_token(). Also you need to specify which algorithms you would like to permit when validating in protected endpoint by settings <code>authjwt_decode_algorithms</code> which take a sequence. If the JWT doesn't have algorithm in <code>authjwt_decode_algorithms</code> the token will be rejected.</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    # Configure algorithms which is permit\n    authjwt_decode_algorithms: set = {\"HS384\", \"HS512\"}\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # You can define different algorithm when create a token\n    access_token = await authorize.create_access_token(\n        subject=user.username, algorithm=\"HS384\"\n    )\n    refresh_token = await authorize.create_refresh_token(\n        subject=user.username, algorithm=\"HS512\"\n    )\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# In protected route, automatically check incoming JWT\n# have algorithm in your `authjwt_decode_algorithms` or not\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# In protected route, automatically check incoming JWT\n# have algorithm in your `authjwt_decode_algorithms` or not\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"},{"location":"advanced-usage/dynamic-expires/","title":"Dynamic Token Expires","text":"<p>You can also change the expires time for a token via parameter expires_time in the create_access_token() or create_refresh_token() function. This takes a datetime.timedelta, integer, or even boolean and overrides the <code>authjwt_access_token_expires</code> and <code>authjwt_refresh_token_expires</code> settings. This can be useful if you have different use cases for different tokens.</p> <pre><code>@app.post('/create-dynamic-token')\ndef create_dynamic_token(Authorize: AuthJWT = Depends()):\n    expires = datetime.timedelta(days=1)\n    token = Authorize.create_access_token(subject=\"test\",expires_time=expires)\n    return {\"token\": token}\n</code></pre> <p>You can even disable expiration by setting expires_time to False:</p> <pre><code>@app.post('/create-token-disable')\ndef create_dynamic_token(Authorize: AuthJWT = Depends()):\n    token = Authorize.create_access_token(subject=\"test\",expires_time=False)\n    return {\"token\": token}\n</code></pre>"},{"location":"advanced-usage/generate-docs/","title":"Generate Documentation","text":"<p>It feels incomplete if there is no documentation because fastapi-jwt-auth that uses starlette request and response directly to get headers or cookies, you must manually generate the documentation. Thanks to <code>FastAPI</code> you can generate doc easily via <code>Extending OpenAPI</code>.</p> <p>Here is an example to generate the doc:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    return {\"access_token\": access_token}\n\n\n@app.get(\"/protected\", operation_id=\"authorize\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\ndef custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n\n    # Custom documentation async-fastapi-jwt-auth\n    headers = {\n        \"name\": \"Authorization\",\n        \"in\": \"header\",\n        \"required\": True,\n        \"schema\": {\"title\": \"Authorization\", \"type\": \"string\"},\n    }\n\n    # Get routes from index 4 because before that fastapi define router for /openapi.json, /redoc, /docs, etc\n    # Get all router where operation_id is \"authorize\"\n    router_authorize = [\n        route for route in app.routes[4:] if route.operation_id == \"authorize\"\n    ]\n\n    for route in router_authorize:\n        method = list(route.methods)[0].lower()\n        try:\n            # If the router has another parameter\n            openapi_schema[\"paths\"][route.path][method][\"parameters\"].append(headers)\n        except Exception:\n            # If the router doesn't have a parameter\n            openapi_schema[\"paths\"][route.path][method].update(\n                {\"parameters\": [headers]}\n            )\n\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema\n\n\napp.openapi = custom_openapi\n</code></pre>"},{"location":"advanced-usage/websocket/","title":"WebSocket Protecting","text":"<p>The WebSocket protocol doesn\u2019t handle authorization or authentication. Practically, this means that a WebSocket opened from a page behind auth doesn\u2019t \"automatically\" receive any sort of auth. You need to take steps to also secure the WebSocket connection.</p> <p>Since you cannot customize WebSocket headers from JavaScript, you\u2019re limited to the \"implicit\" auth (i.e. Basic or cookies) that\u2019s sent from the browser. The more common approach to generates a token from your normal HTTP server and then have the client send the token (either as a query string in the WebSocket path or as the first WebSocket message). The WebSocket server then validates that the token is valid.</p> <p>Note: Change all IP address to your localhost</p> <p>Here is an example of how you authorize from query URL: <pre><code>from fastapi import Depends, FastAPI, HTTPException, Query, Request, WebSocket\nfrom fastapi.responses import HTMLResponse, JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Authorize&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket Authorize&lt;/h1&gt;\n        &lt;p&gt;Token:&lt;/p&gt;\n        &lt;textarea id=\"token\" rows=\"4\" cols=\"50\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;\n        &lt;button onclick=\"websocketfun()\"&gt;Send&lt;/button&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            const websocketfun = () =&gt; {\n                let token = document.getElementById(\"token\").value\n                let ws = new WebSocket(`ws://127.0.0.1:8000/ws?token=${token}`)\n                ws.onmessage = (event) =&gt; {\n                    let messages = document.getElementById('messages')\n                    let message = document.createElement('li')\n                    let content = document.createTextNode(event.data)\n                    message.appendChild(content)\n                    messages.appendChild(message)\n                }\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n\n@app.get(\"/\")\nasync def get():\n    return HTMLResponse(html)\n\n\n@app.websocket(\"/ws\")\nasync def websocket(\n    websocket: WebSocket, token: str = Query(...),\n    authorize: AuthJWT = Depends(auth_dep)\n):\n    await websocket.accept()\n    try:\n        await authorize.jwt_required(\"websocket\", token=token)\n        # Authorize.jwt_optional(\"websocket\",token=token)\n        # Authorize.jwt_refresh_token_required(\"websocket\",token=token)\n        # Authorize.fresh_jwt_required(\"websocket\",token=token)\n        await websocket.send_text(\"Successfully Login!\")\n        decoded_token = await authorize.get_raw_jwt(token)\n        await websocket.send_text(f\"Here your decoded token: {decoded_token}\")\n    except AuthJWTException as err:\n        await websocket.send_text(err.message)\n        await websocket.close()\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(\n        subject=user.username, fresh=True\n    )\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n</code></pre> You will see a simple page like this:</p> <p>You can copy the token from endpoint /login and then send them:</p> <p>And your WebSocket route will respond back if the token is valid or not:</p> <p>Here is an example of how you authorize from cookie: <pre><code>from fastapi import Depends, FastAPI, Query, WebSocket\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    authjwt_token_location: set = {\"cookies\"}\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Authorize&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket Authorize&lt;/h1&gt;\n        &lt;button onclick=\"websocketfun()\"&gt;Send&lt;/button&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            const getCookie = (name) =&gt; {\n                const value = `; ${document.cookie}`;\n                const parts = value.split(`; ${name}=`);\n                if (parts.length === 2) return parts.pop().split(';').shift();\n            }\n\n            const websocketfun = () =&gt; {\n                let csrf_token = getCookie(\"csrf_access_token\")\n\n                let ws = new WebSocket(`ws://127.0.0.1:8000/ws?csrf_token=${csrf_token}`)\n                ws.onmessage = (event) =&gt; {\n                    let messages = document.getElementById('messages')\n                    let message = document.createElement('li')\n                    let content = document.createTextNode(event.data)\n                    message.appendChild(content)\n                    messages.appendChild(message)\n                }\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n\n@app.get(\"/\")\nasync def get():\n    return HTMLResponse(html)\n\n\n@app.websocket(\"/ws\")\nasync def websocket(\n    websocket: WebSocket, csrf_token: str = Query(...),\n    authorize: AuthJWT = Depends(auth_dep)\n):\n    await websocket.accept()\n    try:\n        await authorize.jwt_required(\n            \"websocket\", websocket=websocket, csrf_token=csrf_token\n        )\n        # Authorize.jwt_optional(\"websocket\",websocket=websocket,csrf_token=csrf_token)\n        # Authorize.jwt_refresh_token_required(\"websocket\",websocket=websocket,csrf_token=csrf_token)\n        # Authorize.fresh_jwt_required(\"websocket\",websocket=websocket,csrf_token=csrf_token)\n        await websocket.send_text(\"Successfully Login!\")\n        decoded_token = await authorize.get_raw_jwt()\n        await websocket.send_text(f\"Here your decoded token: {decoded_token}\")\n    except AuthJWTException as err:\n        await websocket.send_text(err.message)\n        await websocket.close()\n\n\n@app.get(\"/get-cookie\")\nasync def get_cookie(authorize: AuthJWT = Depends(auth_dep)):\n    access_token = await authorize.create_access_token(subject=\"test\", fresh=True)\n    refresh_token = await authorize.create_refresh_token(subject=\"test\")\n\n    await authorize.set_access_cookies(access_token)\n    await authorize.set_refresh_cookies(refresh_token)\n    return {\"msg\": \"Successfully login\"}\n</code></pre></p> <p>You will see a simple page like this:</p> <p>You can get the token from URL /get-cookie:</p> <p>And click button send then your WebSocket route will respond back if the cookie and csrf token is match or cookie is valid or not:</p>"},{"location":"configuration/cookies/","title":"Cookies Options","text":"<p>These are only applicable if <code>authjwt_token_location</code> is use cookies.</p> <code>authjwt_access_cookie_key</code> The key of the cookie that holds the access token. Defaults to <code>access_token_cookie</code> <code>authjwt_refresh_cookie_key</code> The key of the cookie that holds the refresh token. Defaults to <code>refresh_token_cookie</code> <code>authjwt_access_cookie_path</code> What path should be set for the access cookie. Defaults to <code>'/'</code>, which will cause this access cookie to be sent in every request. <code>authjwt_refresh_cookie_path</code> What path should be set for the refresh cookie. Defaults to <code>'/'</code>, which will cause this refresh cookie to be sent in every request.  <code>authjwt_cookie_max_age</code> If you don't set anything else, the cookie will expire when the browser is closed. Defaults to <code>None</code>, to prevent this set expiration to <code>int</code> (expressed in a number of seconds). <code>authjwt_cookie_domain</code> The domain can be used to specify a domain and subdomain for your cookies. Defaults to <code>None</code> which sets this cookie to only be readable by the domain that set it.  <code>authjwt_cookie_secure</code> If the secure flag is <code>True</code> cookie can only be transmitted securely over HTTPS, and it will not be sent over unencrypted HTTP connections. Defaults to <code>False</code>, but in production this should likely be set to <code>True</code> <code>authjwt_cookie_samesite</code> The browser sends the cookie with both cross-site and same-site requests. Set to <code>'lax'</code> in production to improve protection for CSRF attacks. Defaults to <code>None</code>, which means cookies are always sent through external or internal site."},{"location":"configuration/csrf/","title":"CSRF Options","text":"<code>authjwt_cookie_csrf_protect</code> Enable/disable CSRF protection when using cookies. Defaults to <code>True</code> <code>authjwt_access_csrf_cookie_key</code> Key of the CSRF access cookie. Defaults to <code>'csrf_access_token'</code> <code>authjwt_refresh_csrf_cookie_key</code> Key of the CSRF refresh cookie. Defaults to <code>'csrf_refresh_token'</code> <code>authjwt_access_csrf_cookie_path</code> Path for the CSRF access cookie. Defaults to <code>'/'</code> <code>authjwt_refresh_csrf_cookie_path</code> Path for the CSRF refresh cookie. Defaults to <code>'/'</code> <code>authjwt_access_csrf_header_name</code> Name of the header that should contain the CSRF double submit value for access tokens. Defaults to <code>X-CSRF-TOKEN</code> <code>authjwt_refresh_csrf_header_name</code> Name of the header that should contains the CSRF double submit value for refresh tokens. Defaults to <code>X-CSRF-TOKEN</code> <code>authjwt_csrf_methods</code> The request methods that will use CSRF protection. Defaults to <code>{'POST','PUT','PATCH','DELETE'}</code>"},{"location":"configuration/denylist/","title":"Denylist Options","text":"<code>authjwt_denylist_enabled</code> Enable/disable token revoking. Defaults to <code>False</code> <code>authjwt_denylist_token_checks</code> What token types to check against the denylist. The options are <code>access</code> or <code>refresh</code>. You can pass in a sequence to check more than one type. Defaults to <code>{'access', 'refresh'}</code>. Only used if deny listing is enabled."},{"location":"configuration/general/","title":"General Options","text":"<code>authjwt_token_location</code> Where to look for a JWT when processing a request. The options are <code>headers</code> or <code>cookies</code>. You can pass in a sequence to set more than one location <code>('headers','cookies')</code>. Defaults to <code>{'headers'}</code> if you pass headers and cookies, headers are precedence. <code>authjwt_secret_key</code> The secret key needed for symmetric based signing algorithms, such as <code>HS*</code>. Defaults to <code>None</code> <code>authjwt_public_key</code> The public key needed for asymmetric based signing algorithms, such as <code>RS*</code> or <code>EC*</code>. PEM format expected. Defaults to <code>None</code> <code>authjwt_private_key</code> The private key needed for asymmetric based signing algorithms, such as <code>RS*</code> or <code>EC*</code>. PEM format expected. Defaults to <code>None</code> <code>authjwt_algorithm</code> Which algorithm to sign the JWT with. See here for the options. Defaults to <code>HS256</code> <code>authjwt_decode_algorithms</code> Which algorithms are allowed to decode a JWT. Defaults to a list with only the algorithm set in <code>authjwt_algorithm</code> <code>authjwt_decode_leeway</code> Define the leeway part of the expiration time definition, which means you can validate an expiration time which is in the past but not very far. Defaults to <code>0</code> <code>authjwt_encode_issuer</code> Define the issuer to set the issuer in JWT claims, only access token have issuer claim. Defaults to <code>None</code> <code>authjwt_decode_issuer</code> Define the issuer to check the issuer in JWT claims, only access token have issuer claim. Defaults to <code>None</code> <code>authjwt_decode_audience</code> The audience or list of audiences you expect in a JWT when decoding it. Defaults to <code>None</code> <code>authjwt_access_token_expires</code> How long an access token should live before it expires. This takes value <code>integer</code> (seconds) or <code>datetime.timedelta</code>, and defaults to 15 minutes. Can be set to <code>False</code> to disable expiration. <code>authjwt_refresh_token_expires</code> How long an refresh token should live before it expires. This takes value <code>integer</code> (seconds) or <code>datetime.timedelta</code>, and defaults to 30 days. Can be set to <code>False</code> to disable expiration."},{"location":"configuration/headers/","title":"Headers Options","text":"<p>These are only applicable if <code>authjwt_token_location</code> is use headers.</p> <code>authjwt_header_name</code> What header to look for the JWT in a request. Defaults to <code>Authorization</code> <code>authjwt_header_type</code> What type of header the JWT is in. Defaults to <code>Bearer</code>. This can be an empty string, in which case the header contains only the JWT instead like <code>HeaderName: Bearer &lt;JWT&gt;</code>"},{"location":"usage/basic/","title":"Basic Usage","text":"<p>Create a file <code>basic.py</code>:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\n# in production, you can use Settings management\n# from pydantic to get secret key from .env\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n# callback to get your configuration\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n# exception handler for authjwt\n# in production, you can tweak performance using orjson response\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n# provide a method to create access tokens. The create_access_token()\n# function is used to actually generate the token to use authorization\n# later in endpoint protected\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # subject identifier for whom this token is for example id or username from database\n    access_token = await authorize.create_access_token(subject=user.username)\n    return {\"access_token\": access_token}\n\n\n# protect endpoint with function jwt_required(), which requires\n# a valid access token in the request headers to access.\n@app.get(\"/user\")\nasync def user(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(\"basic:app\", host=\"0.0.0.0\", port=8000, reload=True)\n</code></pre> <p>Run the server with:</p> <pre><code>$ uvicorn basic:app --host 0.0.0.0\n\nINFO:     Started server process [9859]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\n</code></pre> <p>To access a jwt_required protected url, all we have to do is send in the JWT with the request. By default, this is done with an authorization header that looks like:</p> <pre><code>Authorization: Bearer &lt;access_token&gt;\n</code></pre> <p>We can see this in action using curl:</p> <pre><code>$ curl http://localhost:8000/user\n\n{\"detail\":\"Missing Authorization Header\"}\n\n$ curl -H \"Content-Type: application/json\" -X POST \\\n  -d '{\"username\":\"test\",\"password\":\"test\"}' http://localhost:8000/login\n\n{\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA\"}\n\n$ export TOKEN=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA\n\n$ curl -H \"Authorization: Bearer $TOKEN\" http://localhost:8000/user\n\n{\"user\":\"test\"}\n</code></pre>"},{"location":"usage/freshness/","title":"Freshness Tokens","text":"<p>The fresh tokens pattern is built into this extension. This pattern is very simple, you can choose to mark some access tokens as fresh and other as a non-fresh tokens, and use the fresh_jwt_required() function to only allow fresh tokens to access the certain endpoint.</p> <p>This is useful for allowing the fresh tokens to do some critical things (such as update information user) in real case you can see in the GitHub system when user wants to delete a repository in a certain time you need login if tokens not fresh again. Utilizing Fresh tokens in conjunction with refresh tokens can lead to a more secure site, without creating a bad user experience by making users constantly re-authenticate.</p> <p>Here is an example of how you could utilize refresh tokens with the fresh token pattern:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n# Standard login endpoint. Will return a fresh access token and a refresh token\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    \"\"\"\n    create_access_token supports an optional 'fresh' argument,\n    which marks the token as fresh or non-fresh accordingly.\n    As we just verified their username and password, we are\n    going to mark the token as fresh here.\n    \"\"\"\n    access_token = await authorize.create_access_token(\n        subject=user.username, fresh=True\n    )\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    Refresh token endpoint. This will generate a new access token from\n    the refresh token, but will mark that access token as non-fresh,\n    as we do not actually verify a password in this endpoint.\n    \"\"\"\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(\n        subject=current_user, fresh=False\n    )\n    return {\"access_token\": new_access_token}\n\n\n@app.post(\"/fresh-login\")\nasync def fresh_login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    Fresh login endpoint. This is designed to be used if we need to\n    make a fresh token for a user (by verifying they have the\n    correct username and password). Unlike the standard login endpoint,\n    this will only return a new access token, so that we don't keep\n    generating new refresh tokens, which entirely defeats their point.\n    \"\"\"\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    new_access_token = await authorize.create_access_token(\n        subject=user.username, fresh=True\n    )\n    return {\"access_token\": new_access_token}\n\n\n# Any valid JWT access token can access this endpoint\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\n# Only fresh JWT access token can access this endpoint\n@app.get(\"/protected-fresh\")\nasync def protected_fresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.fresh_jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"},{"location":"usage/jwt-in-cookies/","title":"JWT in Cookies","text":"<p>Highly recommended using JWT in cookies, if your frontend interacts with the backend, your frontend may be storing JWT in the browser localStorage or sessionStorage. There is nothing wrong with this, but if you have any sort of XSS vulnerability on your site, an attacker will be able to trivially steal your tokens. If you want some additional security on your site, you can save your JWT in an httponly cookies. Which keeps javascript cannot be able to access the cookies.</p> <p>Here is a basic example of how to store JWT in cookies:</p> <p>Note</p> <p>You can also create cookies or unset cookies when returning a <code>Response</code> directly in your code. To do that, you can create a response then set the response in set cookies or unset cookies</p> <pre><code>...\nresponse = JSONResponse(content={\"msg\":\"Successfully login\"})\n# Set the JWT and CSRF double submit cookies in the response\nAuthorize.set_access_cookies(access_token,response)\nAuthorize.set_refresh_cookies(refresh_token,response)\nreturn response\n</code></pre> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\n\"\"\"\nNote: This is just a basic example how to enable cookies.\nThis is vulnerable to CSRF attacks, and should not be used this example.\n\"\"\"\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    # Configure application to store and get JWT from cookies\n    authjwt_token_location: set = {\"cookies\"}\n    # Disable CSRF Protection for this example. default is True\n    authjwt_cookie_csrf_protect: bool = False\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # Create the tokens and passing to set_access_cookies or set_refresh_cookies\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n\n    # Set the JWT cookies in the response\n    await authorize.set_access_cookies(access_token)\n    await authorize.set_refresh_cookies(refresh_token)\n    return {\"msg\": \"Successfully login\"}\n\n\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    # Set the JWT cookies in the response\n    await authorize.set_access_cookies(new_access_token)\n    return {\"msg\": \"The token has been refresh\"}\n\n\n@app.delete(\"/logout\")\nasync def logout(authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    Because the JWT are stored in an httponly cookie now, we cannot\n    log the user out by simply deleting the cookies in the frontend.\n    We need the backend to send us a response to delete the cookies.\n    \"\"\"\n    await authorize.jwt_required()\n\n    await authorize.unset_jwt_cookies()\n    return {\"msg\": \"Successfully logout\"}\n\n\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    We do not need to make any changes to our protected endpoints. They\n    will all still function the exact same as they do when sending the\n    JWT in via a headers instead of a cookies\n    \"\"\"\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre> <p>This isn't the full story. However now we can keep our cookies from being stolen via XSS attacks, but session cookies vulnerable to CSRF attacks. To combat CSRF attacks we are going to use a technique called double submit cookie pattern. Double submitting cookies is defined as sending a random value in both a cookie and as a request parameter, with the server verifying if the cookie value and request value are equal.</p>        Double Submit Cookie Pattern      <p>This tokens is saved in a cookie with httponly set to True, so it cannot be accessed via javascript. We will then create a secondary cookie that contains an only random string, but has httponly set to False so that it can be accessed via javascript running on your website.</p> <p>Now in order to access a protected endpoint, you will need to add a custom header that contains the random string in it, and if that header doesn\u2019t exist or it doesn\u2019t match the string that is stored in the JWT, the requester will be kicked out as unauthorized.</p> <p>To break this down, if an attacker attempts to perform a CSRF attack they will send the JWT (via cookie) to protected endpoint, but without the random string in the request headers, they won't be able to access the endpoint. They cannot access the random string unless they can run javascript on your website likely via an XSS attack, and if they are able to perform an XSS attack, they will not be able to steal the actual access and refresh JWT, as javascript is still not able to access those httponly cookies.</p> <p>No system is safe. If an attacker can perform an XSS attack they can still access protected endpoints from people who visit your site. However, it is better than if they were able to steal the access and refresh tokens from local/session storage, and use them whenever they wanted.</p> <p>Here is an example of using cookies with CSRF protection:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\n\"\"\"\nBy default, the CRSF cookies will be called csrf_access_token and\ncsrf_refresh_token, and in protected endpoints we will look\nfor the CSRF token in the 'X-CSRF-Token' headers. only certain\nmethods should define CSRF token in headers default is ('POST','PUT','PATCH','DELETE')\n\"\"\"\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    # Configure application to store and get JWT from cookies\n    authjwt_token_location: set = {\"cookies\"}\n    # Only allow JWT cookies to be sent over https\n    authjwt_cookie_secure: bool = False\n    # Enable csrf double submit protection. default is True\n    authjwt_cookie_csrf_protect: bool = True\n    # Change to 'lax' in production to make your website more secure from CSRF Attacks, default is None\n    # authjwt_cookie_samesite: str = 'lax'\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    With authjwt_cookie_csrf_protect set to True, set_access_cookies() and\n    set_refresh_cookies() will now also set the non-httponly CSRF cookies\n    \"\"\"\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # Create the tokens and passing to set_access_cookies or set_refresh_cookies\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n\n    # Set the JWT and CSRF double submit cookies in the response\n    await authorize.set_access_cookies(access_token)\n    await authorize.set_refresh_cookies(refresh_token)\n    return {\"msg\": \"Successfully login\"}\n\n\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    # Set the JWT and CSRF double submit cookies in the response\n    await authorize.set_access_cookies(new_access_token)\n    return {\"msg\": \"The token has been refresh\"}\n\n\n@app.delete(\"/logout\")\nasync def logout(authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    Because the JWT are stored in an httponly cookie now, we cannot\n    log the user out by simply deleting the cookie in the frontend.\n    We need the backend to send us a response to delete the cookies.\n    \"\"\"\n    await authorize.jwt_required()\n\n    await authorize.unset_jwt_cookies()\n    return {\"msg\": \"Successfully logout\"}\n\n\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"},{"location":"usage/optional/","title":"Partially Protecting","text":"<p>In some cases you want to use one endpoint for both, protected and unprotected. In this situation you can use function jwt_optional(). This will allow the endpoint to be accessed regardless of if a JWT is sent in the request or not. If a JWT get tampering or expired an error will be returned instead of calling the endpoint.</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    return {\"access_token\": access_token}\n\n\n@app.get(\"/partially-protected\")\nasync def partially_protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_optional()\n\n    # If no jwt is sent in the request, get_jwt_subject() will return None\n    current_user = await authorize.get_jwt_subject() or \"anonymous\"\n    return {\"user\": current_user}\n</code></pre>"},{"location":"usage/refresh/","title":"Refresh Tokens","text":"<p>These are long-lived tokens which can be used to create a new access tokens once an old access token has expired. Refresh tokens cannot access an endpoint that is protected with jwt_required(), jwt_optional(), and fresh_jwt_required() and access tokens cannot access an endpoint that is protected with jwt_refresh_token_required().</p> <p>Utilizing refresh tokens we can help reduce the damage that can be done if an access tokens is stolen. However, if an attacker gets a refresh tokens they can keep generating new access tokens and accessing protected endpoints as though he was that user. We can help combat this by using the fresh tokens pattern, discussed in the next section.</p> <p>Note</p> <p>For accessing /refresh endpoint remember to change access_token with refresh_token in the header <code>Authorization: Bearer &lt;refresh_token&gt;</code></p> <p>Here is an example of using access and refresh tokens:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # Use create_access_token() and create_refresh_token() to create our\n    # access and refresh tokens\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    \"\"\"\n    The jwt_refresh_token_required() function insures a valid refresh\n    token is present in the request before running any code below that function.\n    we can use the get_jwt_subject() function to get the subject of the refresh\n    token, and use the create_access_token() function again to make a new access token\n    \"\"\"\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"},{"location":"usage/revoking/","title":"Revoking Tokens","text":"<p>This will allow you to revoke a specific tokens so that it can no longer access your endpoints. You will have to choose what tokens you want to check against the denylist. Denylist works by providing a callback function to this extension, using the token_in_denylist_loader(). This method will be called whenever the specified tokens (access and/or refresh) is used to access a protected endpoint. If the callback function says that the tokens is revoked, we will not allow the requester to continue, otherwise we will allow the requester to access the endpoint as normal.</p> <p>Here is a basic example use tokens revoking:</p> <pre><code>from fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\n# set denylist enabled to True\n# you can set to check access or refresh token or even both of them\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    authjwt_denylist_enabled: bool = True\n    authjwt_denylist_token_checks: set = {\"access\", \"refresh\"}\n\n\n@AuthJWT.load_config\ndef get_config():\n    return Settings()\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n# A storage engine to save revoked tokens. in production,\n# you can use Redis for storage system\ndenylist = set()\n\n\n# For this example, we are just checking if the tokens jti\n# (unique identifier) is in the denylist set. This could\n# be made more complex, for example storing the token in Redis\n# with the value true if revoked and false if not revoked\n@AuthJWT.token_in_denylist_loader\nasync def check_if_token_in_denylist(decrypted_token):\n    jti = decrypted_token[\"jti\"]\n    return jti in denylist\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# Standard refresh endpoint. Token in denylist will not\n# be able to access this endpoint\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# Endpoint for revoking the current users access token\n@app.delete(\"/access-revoke\")\nasync def access_revoke(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    jti = (await authorize.get_raw_jwt())[\"jti\"]\n    denylist.add(jti)\n    return {\"detail\": \"Access token has been revoke\"}\n\n\n# Endpoint for revoking the current users refresh token\n@app.delete(\"/refresh-revoke\")\nasync def refresh_revoke(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    jti = (await authorize.get_raw_jwt())[\"jti\"]\n    denylist.add(jti)\n    return {\"detail\": \"Refresh token has been revoke\"}\n\n\n# A token in denylist will not be able to access this anymore\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre> <p>In production, you will likely want to use either a database or in-memory store (such as Redis) to store your tokens. Memory stores are great if you are wanting to revoke a tokens when the users log out and you can define timeout to your tokens in Redis, after the timeout has expired, the tokens will automatically be deleted.</p> <p>Note</p> <p>Before that make sure redis already installed on your local machine, you can use docker using this command <code>docker run -d -p 6379:6379 redis</code></p> <p>Here example use Redis for revoking a tokens:</p> <pre><code>#   This example has not been tested with this async fork, if it worked for you - write to me :)\nfrom datetime import timedelta\n\nfrom fastapi import Depends, FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\nfrom redis import Redis\n\nfrom async_fastapi_jwt_auth import AuthJWT\nfrom async_fastapi_jwt_auth.exceptions import AuthJWTException\nfrom async_fastapi_jwt_auth.auth_jwt import AuthJWTBearer\n\napp = FastAPI()\nauth_dep = AuthJWTBearer()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Settings(BaseModel):\n    authjwt_secret_key: str = \"secret\"\n    authjwt_denylist_enabled: bool = True\n    authjwt_denylist_token_checks: set = {\"access\", \"refresh\"}\n    access_expires: int = timedelta(minutes=15)\n    refresh_expires: int = timedelta(days=30)\n\n\nsettings = Settings()\n\n\n@AuthJWT.load_config\ndef get_config():\n    return settings\n\n\n@app.exception_handler(AuthJWTException)\ndef authjwt_exception_handler(request: Request, exc: AuthJWTException):\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.message})\n\n\n# Setup our redis connection for storing the denylist tokens\nredis_conn = Redis(host=\"localhost\", port=6379, db=0, decode_responses=True)\n\n\n# Create our function to check if a token has been revoked. In this simple\n# case, we will just store the tokens jti (unique identifier) in redis.\n# This function will return the revoked status of a token. If a token exists\n# in redis and value is true, token has been revoked\n@AuthJWT.token_in_denylist_loader\nasync def check_if_token_in_denylist(decrypted_token):\n    jti = decrypted_token[\"jti\"]\n    entry = redis_conn.get(jti)\n    return entry and entry == \"true\"\n\n\n@app.post(\"/login\")\nasync def login(user: User, authorize: AuthJWT = Depends(auth_dep)):\n    if user.username != \"test\" or user.password != \"test\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = await authorize.create_access_token(subject=user.username)\n    refresh_token = await authorize.create_refresh_token(subject=user.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# Standard refresh endpoint. Token in denylist will not\n# be able to access this endpoint\n@app.post(\"/refresh\")\nasync def refresh(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    current_user = await authorize.get_jwt_subject()\n    new_access_token = await authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# Endpoint for revoking the current users access token\n@app.delete(\"/access-revoke\")\nasync def access_revoke(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    # Store the tokens in redis with the value true for revoked.\n    # We can also set an expires time on these tokens in redis,\n    # so they will get automatically removed after they expired.\n    jti = (await authorize.get_raw_jwt())[\"jti\"]\n    redis_conn.setex(jti, settings.access_expires, \"true\")\n    return {\"detail\": \"Access token has been revoke\"}\n\n\n# Endpoint for revoking the current users refresh token\n@app.delete(\"/refresh-revoke\")\nasync def refresh_revoke(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_refresh_token_required()\n\n    jti = (await authorize.get_raw_jwt())[\"jti\"]\n    redis_conn.setex(jti, settings.refresh_expires, \"true\")\n    return {\"detail\": \"Refresh token has been revoke\"}\n\n\n# A token in denylist will not be able to access this anymore\n@app.get(\"/protected\")\nasync def protected(authorize: AuthJWT = Depends(auth_dep)):\n    await authorize.jwt_required()\n\n    current_user = await authorize.get_jwt_subject()\n    return {\"user\": current_user}\n</code></pre>"}]}